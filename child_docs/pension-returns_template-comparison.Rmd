# Compare pension plans

## Risk of loss

Risk of loss at least as big as `x` percent for a single period (year).  
`x` values are row names.  

```{r}
percent_vals = c(0, 5, 10, 25, 50, 90, 99)
# risk_percentiles_df <-  data.frame(
#       #Percent = percent_vals,
#       Vel_m = risk_percentiles(fit_vmr$quantile_data, percent_vals, "loss"),
#       Vel_ml = risk_percentiles(fit_vmrl$quantile_data, percent_vals, "loss"),
#       Vel_h = risk_percentiles(fit_vhr$quantile_data, percent_vals, "loss"),
#       PFA_m = risk_percentiles(fit_pmr$quantile_data, percent_vals, "loss"),
#       PFA_h = risk_percentiles(fit_phr$quantile_data, percent_vals, "loss"),
#       mix_m = risk_percentiles(fit_mmr$quantile_data, percent_vals, "loss"),
#       mix_h = risk_percentiles(fit_mhr$quantile_data, percent_vals, "loss"),
#       vm_ph = risk_percentiles(fit_vm_ph$quantile_data, percent_vals, "loss"),
#       vh_pm = risk_percentiles(fit_vh_pm$quantile_data, percent_vals, "loss")
# )
risk_percentiles_df <- as.data.frame(lapply(
  fits,
  function(fit) {
    risk_percentiles(fit$quantile_data, percent_vals, "loss")
  }
))
colnames(risk_percentiles_df) <- fund_names
rownames(risk_percentiles_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(risk_percentiles_df, digits = 3)
```


### Worst ranking for loss percentiles

```{r}
knitr::kable(rank_summary(risk_percentiles_df, sorting = rep("hi", length(percent_vals))), digits = 3)
```

## Chance of min gains

Chance of gains of at least `x` percent for a single period (year).  
`x` values are row names.

```{r}
percent_vals = c(0, 5, 10, 25, 50, 100)
# gain_percentiles_df <-  data.frame(
#       #Percent = percent_vals,
#       Velliv_m = risk_percentiles(fit_vmr$quantile_data, percent_vals, "gain"),
#       Velliv_m_l = risk_percentiles(fit_vmrl$quantile_data, percent_vals, "gain"),
#       Velliv_h = risk_percentiles(fit_vhr$quantile_data, percent_vals, "gain"),
#       PFA_m = risk_percentiles(fit_pmr$quantile_data, percent_vals, "gain"),
#       PFA_h = risk_percentiles(fit_phr$quantile_data, percent_vals, "gain"),
#       mix_m = risk_percentiles(fit_mmr$quantile_data, percent_vals, "gain"),
#       mix_h = risk_percentiles(fit_mhr$quantile_data, percent_vals, "gain"),
#       vm_ph = risk_percentiles(fit_vm_ph$quantile_data, percent_vals, "gain"),
#       vh_pm = risk_percentiles(fit_vh_pm$quantile_data, percent_vals, "gain")
# )
gain_percentiles_df <- as.data.frame(lapply(
  fits,
  function(fit) {
    risk_percentiles(fit$quantile_data, percent_vals, "gain")
  }
))
colnames(gain_percentiles_df) <- fund_names
rownames(gain_percentiles_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(gain_percentiles_df, digits = 3)
```

### Best ranking for gains percentiles

```{r}
knitr::kable(rank_summary(gain_percentiles_df, sorting = rep("hi", length(percent_vals))), digits = 3)
```


## MC risk percentiles

Risk of loss at least as big as row name in percent from first to last period.  

```{r}
percent_vals = c(0, 5, 10, 25, 50, 90, 99)
# mc_loss_percentiles_df <-  data.frame(
#       #Percent = percent_vals,
#       Vel_m = risk_percentiles(log(unlist(mc_vmr$mc_df[20, ])/100), percent_vals, "loss"),
#       Vel_ml = risk_percentiles(log(unlist(mc_vmrl$mc_df[20, ])/100), percent_vals, "loss"),
#       Vel_h = risk_percentiles(log(unlist(mc_vhr$mc_df[20, ])/100), percent_vals, "loss"),
#       PFA_m = risk_percentiles(log(unlist(mc_pmr$mc_df[20, ])/100), percent_vals, "loss"),
#       PFA_h = risk_percentiles(log(unlist(mc_phr$mc_df[20, ])/100), percent_vals, "loss"),
#       mix_ma = risk_percentiles(log(unlist(mc_mmr_a$mc_df[20, ])/100), percent_vals, "loss"),
#       mix_ha = risk_percentiles(log(unlist(mc_mhr_a$mc_df[20, ])/100), percent_vals, "loss"),
#       mix_mb = risk_percentiles(log(unlist(mc_mmr_b$mc_df[20, ])/100), percent_vals, "loss"),
#       mix_hb = risk_percentiles(log(unlist(mc_mhr_b$mc_df[20, ])/100), percent_vals, "loss"),
#       vm_ph = risk_percentiles(log(unlist(mc_vm_ph$mc_df[20, ])/100), percent_vals, "loss"),
#       vh_pm = risk_percentiles(log(unlist(mc_vh_pm$mc_df[20, ])/100), percent_vals, "loss")
# )
mc_loss_percentiles_df <- as.data.frame(lapply(
  mc_output,
  function(x) {
    risk_percentiles(log(unlist(x$mc_df[20, ])/100), percent_vals, "loss")
  }
))
colnames(mc_loss_percentiles_df) <- fund_names
rownames(mc_loss_percentiles_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(mc_loss_percentiles_df, digits = 3)
```

1e6 simulation paths of `mhr`:
```{r}
# percent_vals = c(0, 5, 10, 25, 50, 90, 99)
# mc_mhr_b_many_mc_loss_percentiles <-
#   data.frame(
#     percentiles = percent_vals,
#     prob=risk_percentiles(log(unlist(mc_mhr_b_many$mc_df[20, ])/100), percent_vals, "loss")
#   )
# 
# t(mc_mhr_b_many_mc_loss_percentiles)
```

```{r}
# knitr::kable(t(mc_mhr_b_many_mc_loss_percentiles), digits = 3)
```

```{r}
percent_vals = c(0, 5, 10, 25, 50, 90, 99)
mc_mhr_b_many_mc_loss_percentiles <- 
  data.frame(
    prob_pct = c(0.118, 0.095, 0.076, 0.036, 8e-03, 0, 0)
  )
rownames(mc_mhr_b_many_mc_loss_percentiles) <- as.character(percent_vals)
```

```{r}
knitr::kable(t(mc_mhr_b_many_mc_loss_percentiles), digits = 3)
```

### Worst ranking for MC loss percentiles

```{r}
knitr::kable(rank_summary(mc_loss_percentiles_df, sorting = rep("hi", length(percent_vals))), digits = 3)
```


## MC gains percentiles

```{r}
percent_vals = c(0, 5, 10, 25, 50, 100, 200, 300, 400, 500, 1000)
# mc_gain_percentiles_df <-  data.frame(
#       #Percent = percent_vals,
#       Vel_m = risk_percentiles(log(unlist(mc_vmr$mc_df[20, ])/100), percent_vals, "gain"),
#       Vel_ml = risk_percentiles(log(unlist(mc_vmrl$mc_df[20, ])/100), percent_vals, "gain"),
#       Vel_h = risk_percentiles(log(unlist(mc_vhr$mc_df[20, ])/100), percent_vals, "gain"),
#       PFA_m = risk_percentiles(log(unlist(mc_pmr$mc_df[20, ])/100), percent_vals, "gain"),
#       PFA_h = risk_percentiles(log(unlist(mc_phr$mc_df[20, ])/100), percent_vals, "gain"),
#       mix_ma = risk_percentiles(log(unlist(mc_mmr_a$mc_df[20, ])/100), percent_vals, "gain"),
#       mix_ha = risk_percentiles(log(unlist(mc_mhr_a$mc_df[20, ])/100), percent_vals, "gain"),
#       mix_mb = risk_percentiles(log(unlist(mc_mmr_b$mc_df[20, ])/100), percent_vals, "gain"),
#       mix_hb = risk_percentiles(log(unlist(mc_mhr_b$mc_df[20, ])/100), percent_vals, "gain"),
#       vm_ph = risk_percentiles(log(unlist(mc_vm_ph$mc_df[20, ])/100), percent_vals, "gain"),
#       vh_pm = risk_percentiles(log(unlist(mc_vh_pm$mc_df[20, ])/100), percent_vals, "gain")
# )
mc_gain_percentiles_df <- as.data.frame(lapply(
  mc_output,
  function(x) {
    risk_percentiles(log(unlist(x$mc_df[20, ])/100), percent_vals, "gain")
  }
))
colnames(mc_gain_percentiles_df) <- fund_names
rownames(mc_gain_percentiles_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(mc_gain_percentiles_df, digits = 3)
```

1e6 simulation paths of `mhr`: 

```{r}
# percent_vals = c(0, 5, 10, 25, 50, 100, 200, 300, 400, 500, 1000)
# mc_mhr_b_many_mc_loss_percentiles <-
#   data.frame(
#     percentiles = percent_vals,
#     prob=risk_percentiles(log(unlist(mc_mhr_b_many$mc_df[20, ])/100), percent_vals, "gain")
#   )
# t(mc_mhr_b_many_mc_loss_percentiles)
```

```{r}
percent_vals = c(0, 5, 10, 25, 50, 100, 200, 300, 400, 500, 1000)
mc_mhr_b_many_mc_gains_percentiles <- 
  data.frame(
    prob = c(99.8819, 99.8536, 99.824, 99.6861, 99.3009, 97.5134, 86.9115, 65.992, 41.486, 21.6928, 8.65e-02)
  )

rownames(mc_mhr_b_many_mc_gains_percentiles) <- as.character(percent_vals)
```

```{r}
knitr::kable(t(mc_mhr_b_many_mc_gains_percentiles), digits = 3)
```


### Best ranking for MC gains percentiles

```{r}
knitr::kable(rank_summary(mc_gain_percentiles_df[1:6, ], sorting = rep("hi", length(percent_vals))), digits = 3)
```

```{r}
knitr::kable(rank_summary(mc_gain_percentiles_df[7:11, ], sorting = rep("hi", length(percent_vals))), digits = 3)
```


## Summary statistics  

### Fit summary

Summary for fit of log returns to an F-S skew standardized Student-t distribution.  
`m`  is the location parameter.  
`s` is the scale parameter.  
`nu` is the estimated degrees of freedom, or shape parameter.  
`xi` is the estimated skewness parameter.  

```{r}
# fit_summary <- data.frame(
#   Vel_m = c(fit_vmr$m, fit_vmr$s, fit_vmr$nu, fit_vmr$xi, fit_vmr$r_squared),
#   Vel_ml = c(fit_vmrl$m, fit_vmrl$s, fit_vmrl$nu, fit_vmrl$xi, fit_vmrl$r_squared),
#   Vel_h = c(fit_vhr$m, fit_vhr$s, fit_vhr$nu, fit_vhr$xi, fit_vhr$r_squared),
#   PFA_m = c(fit_pmr$m, fit_pmr$s, fit_pmr$nu, fit_pmr$xi, fit_pmr$r_squared),
#   PFA_h = c(fit_phr$m, fit_phr$s, fit_phr$nu, fit_phr$xi, fit_phr$r_squared),
#   mix_m = c(fit_mmr$m, fit_mmr$s, fit_mmr$nu, fit_mmr$xi, fit_mmr$r_squared),
#   mix_h = c(fit_mhr$m, fit_mhr$s, fit_mhr$nu, fit_mhr$xi, fit_mhr$r_squared),
#   vm_ph = c(fit_vm_ph$m, fit_vm_ph$s, fit_vm_ph$nu, fit_vm_ph$xi, fit_vm_ph$r_squared),
#   vh_pm = c(fit_vh_pm$m, fit_vh_pm$s, fit_vh_pm$nu, fit_vh_pm$xi, fit_vh_pm$r_squared)
# )
fit_summary <- as.data.frame(lapply(
  fits,
  function(fit) {
     c(fit$m, fit$s, fit$nu, fit$xi, fit$r_squared)
  }
))
colnames(fit_summary) <- fund_names
rownames(fit_summary) <- c("m", "s", "nu", "xi", "R^2")
```

```{r}
knitr::kable(fit_summary, digits = 3)
```

#### Fit statistics ranking

```{r}
knitr::kable(rank_summary(fit_summary[c(1, 2, 5), ], sorting = c("hi", "lo", "hi")), digits = 3)
```



### Monte Carlo simulations summary

Monte Carlo simulations of portfolio index values (currency values).  
Statistics are given for the final state of all paths.  
Probability of down-and_out is calculated as the share of paths that reach 0 at
some point. All subsequent values for a path are set to 0, if the path reaches
at any point.  
0 is defined as any value below a threshold.    
`dai_pct` (for down-and-in) is the probability of losing money. This is calculated as the 
share of paths finishing below index 100.  

```{r}
cat("Number of paths:", mc_num_paths, "\n")
```


```{r}
# mc_summary <- data.frame(
#   Vel_m = c(mc_vmr$mc_m, mc_vmr$mc_s, mc_vmr$mc_min, mc_vmr$mc_max, mc_vmr$dao_probability_percent, mc_vmr$percent_losing_paths),
#   Vel_ml = c(mc_vmrl$mc_m, mc_vmrl$mc_s, mc_vmrl$mc_min, mc_vmrl$mc_max, mc_vmrl$dao_probability_percent, mc_vmrl$percent_losing_paths),
#   Vel_h = c(mc_vhr$mc_m, mc_vhr$mc_s, mc_vhr$mc_min, mc_vhr$mc_max, mc_vhr$dao_probability_percent, mc_vhr$percent_losing_paths),
#   PFA_m = c(mc_pmr$mc_m, mc_pmr$mc_s, mc_pmr$mc_min, mc_pmr$mc_max, mc_pmr$dao_probability_percent, mc_pmr$percent_losing_paths),
#   PFA_h = c(mc_phr$mc_m, mc_phr$mc_s, mc_phr$mc_min, mc_phr$mc_max, mc_phr$dao_probability_percent, mc_phr$percent_losing_paths),
#   mix_ma = c(mc_mmr_a$mc_m, mc_mmr_a$mc_s, mc_mmr_a$mc_min, mc_mmr_a$mc_max, mc_mmr_a$dao_probability_percent, mc_mmr_a$percent_losing_paths),
#   mix_mb = c(mc_mmr_b$mc_m, mc_mmr_b$mc_s, mc_mmr_b$mc_min, mc_mmr_b$mc_max, mc_mmr_b$dao_probability_percent, mc_mmr_b$percent_losing_paths),
#   mix_ha = c(mc_mhr_a$mc_m, mc_mhr_a$mc_s, mc_mhr_a$mc_min, mc_mhr_a$mc_max, mc_mhr_a$dao_probability_percent, mc_mhr_a$percent_losing_paths),
#   mix_hb = c(mc_mhr_b$mc_m, mc_mhr_b$mc_s, mc_mhr_b$mc_min, mc_mhr_b$mc_max, mc_mhr_b$dao_probability_percent, mc_mhr_b$percent_losing_paths),
#   vm_ph = c(mc_vm_ph$mc_m, mc_vm_ph$mc_s, mc_vm_ph$mc_min, mc_vm_ph$mc_max, mc_vm_ph$dao_probability_percent, mc_vm_ph$percent_losing_paths),
#   vh_pm = c(mc_vh_pm$mc_m, mc_vh_pm$mc_s, mc_vh_pm$mc_min, mc_vh_pm$mc_max, mc_vh_pm$dao_probability_percent, mc_vh_pm$percent_losing_paths)
# )
mc_summary <- as.data.frame(lapply(
  mc_output,
  function(x) {
    c(x$mc_m, x$mc_s, x$mc_min, x$mc_max, x$dao_probability_percent, x$percent_losing_paths)
  }
))
colnames(mc_summary) <- fund_names
rownames(mc_summary) <- c("mc_m", "mc_s", "mc_min", "mc_max", "dao_pct", "dai_pct")
```

```{r}
knitr::kable(mc_summary, digits = 2)
```


#### Ranking

```{r}
knitr::kable(rank_summary(mc_summary, sorting = c("hi", "lo", "hi", "hi", "lo", "lo")), digits = 2)
```

# Compare Gaussian and skewed t-distribution fits

## Gaussian fits

```{r}
fits_norm <- as.data.frame(lapply(
  data_df,
  function(x) {
    fit_g <- fit_gauss(x)
    c(fit_g$par[1], fit_g$par[2])
  }
))
rownames(fits_norm) <- c("m", "s")
```

```{r}
knitr::kable(fits_norm, digits = 3)
```

```{r fig.width=9, fig.height=12}
plot_norm_cdf <- function(x, m, s, minx, maxx, i) {
  plot(seq(from = minx, to = maxx, length.out = 100), pnorm(seq(from = minx, to = maxx, length.out = 100), m, s), pch = 16, cex = 0.3, type = "l", main = names(data_df)[i], xlab = "p", ylab = "log-return")
  abline(v = c(min(x), max(x)), col = c("red", "green"))
  abline(h = c(pnorm(min(x), m, s), pnorm(max(x), m,s)), col = c("red", "green"))
}

par(mfrow = c(4, 2))
for(i in 1:ncol(data_df)) {
  m <- fits_norm[, i][1]
  s <- fits_norm[, i][2]
  plot_norm_cdf(data_df[, i], m, s, -0.3, 0.3, i)
}
par(mfrow = c(1, 1))
```

### Gaussian QQ plots

```{r fig.width=9, fig.height=12}
plot_norm_qq <- function(x, m, s, i) {
  qqnorm((x - m) / s, main = names(data_df)[i])
  qqline((x - m) / s)
  abline(0, 1, col = "red")
  legend("bottomright", legend = c("fit", "y=x"), col = c("black", "red"), lty = 1)
}

par(mfrow = c(4, 2))
for(i in 1:ncol(data_df)) {
  m <- fits_norm[, i][1]
  s <- fits_norm[, i][2]
  plot_norm_qq(data_df[, i], m, s, i)
}
par(mfrow = c(1, 1))
```

### Gaussian vs skewed t

```{r}
# norm_probs <- as.data.frame(lapply(data_df, function(x) {
#   c(
#     pnorm(min(x), mean(x), sd(x)) * 100, 
#     (1 - pnorm(max(x), mean(x), sd(x))) * 100
#   )
# }))[, c(1, 4,2, 5, 3, 6)]
# rownames(norm_probs) <- c("P(X_min)", "P(X_max)")

make_extreme_probs <- function(data_df) {
  extreme_probs <- data.frame(matrix(4 * ncol(data_df), 4, ncol(data_df)))
  for(i in 1:ncol(data_df)) {
    x <- data_df[, i]
    extreme_probs[, i] <- c(
      pnorm(min(x), fits_norm["m", i], fits_norm["s", i]) * 100, 
      (1 - pnorm(max(x), fits_norm["m", i], fits_norm["s", i])) * 100,
      psstd(min(x), fit_summary["m", i], fit_summary["s", i], fit_summary["nu", i], fit_summary["xi", i]) * 100, 
      (1 - psstd(max(x), fit_summary["m", i], fit_summary["s", i], fit_summary["nu", i], fit_summary["xi", i])) * 100
    )
  }
  extreme_probs
}
extreme_probs <- make_extreme_probs(data_df)
colnames(extreme_probs) <- colnames(data_df)
rownames(extreme_probs) <- c("P_norm(X_min)", "P_norm(X_max)", "P_t(X_min)", "P_t(X_max)")


avg_yrs_btw_events <- 100/extreme_probs
rownames(avg_yrs_btw_events) <- c("norm: avg yrs btw min", "norm: avg yrs btw max", "t: avg yrs btw min", "t: avg yrs btw max")
```

Probability in percent that the smallest and largest (respectively) observed return for each fund was generated by a normal distribution:
```{r}
knitr::kable(extreme_probs, digits = 3)
```

Average number of years between min or max events (respectively):
```{r}
knitr::kable(avg_yrs_btw_events, digits = 3)
```


For different given probabilities that returns are Gaussian, what is the probability that the distribution is Gaussian rather than skewed t-distributed, given the smallest/largest observed log-returns?

Conditional probabilities for smallest observed log-returns:

```{r}
# Defining the different probabilities for P[gaussian]
p_gaussian_values <- 1 - 10^(-(seq(0, 6, length.out = 100)))
par(mfrow = c(2, 4))
lapply(
  seq_along(data_df),
  function(i) {
    probs <- bayes_survival(
      p_gaussian_values, 
      min(data_df[[i]]),
      fits_norm[[1]],
      c(fits[[1]]$m, fits[[1]]$s, fits[[1]]$nu, fits[[1]]$xi),
      mode = "min"
    )
    plot(p_gaussian_values, probs[[2]], pch = 16, cex = 0.3, 
         xlab = "P[Gauss]", ylab = "P[Gauss | event]",
         main = fund_names[i]
    )
    abline(0, 1, col = "red")
  }
)
par(mfrow = c(1, 1))
```

```{r}
p_gaussian_values <- c(0.5, 0.9, 0.95, 0.99, 0.999)
wittgenstein_min <- as.data.frame(lapply(
  seq_along(data_df),
  function(i) {
    probs <- bayes_survival(
      p_gaussian_values, 
      min(data_df[[i]]),
      fits_norm[[1]],
      c(fits[[1]]$m, fits[[1]]$s, fits[[1]]$nu, fits[[1]]$xi),
      mode = "min"
    )
    probs[[2]]
  }
))
colnames(wittgenstein_min) <- fund_names
rownames(wittgenstein_min) <- p_gaussian_values
```

```{r}
knitr::kable(wittgenstein_min, digits = 3)
```



Conditional probabilities for smallest observed log-returns:

```{r}
# Defining the different probabilities for P[gaussian]
p_gaussian_values <- 1 - 10^(-(seq(0, 6, length.out = 100)))
par(mfrow = c(2, 4))
lapply(
  seq_along(data_df),
  function(i) {
    probs <- bayes_survival(
      p_gaussian_values, 
      max(data_df[[i]]),
      fits_norm[[1]],
      c(fits[[1]]$m, fits[[1]]$s, fits[[1]]$nu, fits[[1]]$xi),
      mode = "max"
    )
    plot(p_gaussian_values, probs[[2]], pch = 16, cex = 0.3, 
         xlab = "P[Gauss]", ylab = "P[Gauss | event]",
         main = fund_names[i]
    )
    abline(0, 1, col = "red")
  }
)
par(mfrow = c(1, 1))
```

```{r}
p_gaussian_values <- c(0.5, 0.9, 0.95, 0.99, 0.999)
wittgenstein_min <- as.data.frame(lapply(
  seq_along(data_df),
  function(i) {
    probs <- bayes_survival(
      p_gaussian_values, 
      max(data_df[[i]]),
      fits_norm[[1]],
      c(fits[[1]]$m, fits[[1]]$s, fits[[1]]$nu, fits[[1]]$xi),
      mode = "max"
    )
    probs[[2]]
  }
))
colnames(wittgenstein_min) <- fund_names
rownames(wittgenstein_min) <- p_gaussian_values
```

```{r}
knitr::kable(wittgenstein_min, digits = 3)
```
