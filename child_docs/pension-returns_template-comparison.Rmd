# Compare pension plans

## Risk of loss

Risk of loss at least as big as row name in percent for a single period (year).

Skewed $t$-distribution (sstd):  

```{r}
percent_vals = c(0, 5, 10, 25, 50, 90, 99)
```

```{r}
risk_percentiles_df <- as.data.frame(lapply(
  fits,
  function(fit) {
    risk_percentiles(fit$quantile_data, percent_vals, "loss")
  }
))
colnames(risk_percentiles_df) <- fund_names
rownames(risk_percentiles_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(risk_percentiles_df, digits = 3)
```


Standardized $t$-distribution (std):  

```{r}
risk_percentiles_std_df <- as.data.frame(lapply(
  fits_std,
  function(fit) {
    risk_percentiles(fit$quantile_data, percent_vals, "loss")
  }
))
colnames(risk_percentiles_std_df) <- fund_names
rownames(risk_percentiles_std_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(risk_percentiles_std_df, digits = 3)
```


Normal distribution:  

```{r}
risk_percentiles_norm_df <- as.data.frame(lapply(
  fits_norm,
  function(fit) {
    risk_percentiles(fit$quantile_data, percent_vals, "loss")
  }
))
colnames(risk_percentiles_norm_df) <- fund_names
rownames(risk_percentiles_norm_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(risk_percentiles_norm_df, digits = 3)
```


### Worst ranking for loss percentiles

Skewed $t$-distribution (sstd):  

```{r}
knitr::kable(rank_summary(risk_percentiles_df, sorting = rep("hi", length(percent_vals))), digits = 3)
```


Standardized $t$-distribution (std):  

```{r}
knitr::kable(rank_summary(risk_percentiles_std_df, sorting = rep("hi", length(percent_vals))), digits = 3)
```


Normal distribution:  

```{r}
knitr::kable(rank_summary(risk_percentiles_norm_df, sorting = rep("hi", length(percent_vals))), digits = 3)
```


## Chance of min gains

Chance of gains of at least `x` percent for a single period (year).  
`x` values are row names.


Skewed $t$-distribution (sstd):  

```{r}
percent_vals = c(0, 5, 10, 25, 50, 100)
```

```{r}
gain_percentiles_df <- as.data.frame(lapply(
  fits,
  function(fit) {
    risk_percentiles(fit$quantile_data, percent_vals, "gain")
  }
))
colnames(gain_percentiles_df) <- fund_names
rownames(gain_percentiles_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(gain_percentiles_df, digits = 3)
```


Standardized $t$-distribution (std):  

```{r}
gain_percentiles_std_df <- as.data.frame(lapply(
  fits_std,
  function(fit) {
    risk_percentiles(fit$quantile_data, percent_vals, "gain")
  }
))
colnames(gain_percentiles_std_df) <- fund_names
rownames(gain_percentiles_std_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(gain_percentiles_std_df, digits = 3)
```


Normal distribution:  

```{r}
gain_percentiles_norm_df <- as.data.frame(lapply(
  fits_norm,
  function(fit) {
    risk_percentiles(fit$quantile_data, percent_vals, "gain")
  }
))
colnames(gain_percentiles_norm_df) <- fund_names
rownames(gain_percentiles_norm_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(gain_percentiles_norm_df, digits = 3)
```



### Best ranking for gains percentiles


Skewed $t$-distribution (sstd):  

```{r}
knitr::kable(rank_summary(gain_percentiles_df, sorting = rep("hi", length(percent_vals))), digits = 3)
```


Standardized $t$-distribution (std):  

```{r}
knitr::kable(rank_summary(gain_percentiles_std_df, sorting = rep("hi", length(percent_vals))), digits = 3)
```


Normal distribution:  

```{r}
knitr::kable(rank_summary(gain_percentiles_norm_df, sorting = rep("hi", length(percent_vals))), digits = 3)
```


## MC risk percentiles

Risk of loss at least as big as row name in percent from first to last period.  

```{r}
percent_vals = c(0, 5, 10, 25, 50, 90, 99)
```


Skewed $t$-distribution (sstd):  

```{r}
mc_loss_percentiles_df <- as.data.frame(lapply(
  mc_output,
  function(x) {
    risk_percentiles(log(unlist(x$mc_df[20, ])/100), percent_vals, "loss")
  }
))
colnames(mc_loss_percentiles_df) <- fund_names
rownames(mc_loss_percentiles_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(mc_loss_percentiles_df, digits = 3)
```

1e6 sstd simulation paths of `mhr`:  

```{r}
# percent_vals = c(0, 5, 10, 25, 50, 90, 99)
# mc_mhr_b_many_mc_loss_percentiles <-
#   data.frame(
#     percentiles = percent_vals,
#     prob=risk_percentiles(log(unlist(mc_mhr_b_many$mc_df[20, ])/100), percent_vals, "loss")
#   )
# 
# t(mc_mhr_b_many_mc_loss_percentiles)
```

```{r}
# knitr::kable(t(mc_mhr_b_many_mc_loss_percentiles), digits = 3)
```

```{r}
percent_vals = c(0, 5, 10, 25, 50, 90, 99)
mc_mhr_b_many_mc_loss_percentiles <- 
  data.frame(
    prob_pct = c(0.118, 0.095, 0.076, 0.036, 8e-03, 0, 0)
  )
rownames(mc_mhr_b_many_mc_loss_percentiles) <- as.character(percent_vals)
```

```{r}
knitr::kable(t(mc_mhr_b_many_mc_loss_percentiles), digits = 3)
```


Standardized $t$-distribution (std):  

```{r}
mc_loss_percentiles_std_df <- as.data.frame(lapply(
  mc_output_std,
  function(x) {
    risk_percentiles(log(unlist(x$mc_df[20, ])/100), percent_vals, "loss")
  }
))
colnames(mc_loss_percentiles_std_df) <- fund_names
rownames(mc_loss_percentiles_std_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(mc_loss_percentiles_std_df, digits = 3)
```


Normal distribution:  

```{r}
mc_loss_percentiles_norm_df <- as.data.frame(lapply(
  mc_output_norm,
  function(x) {
    risk_percentiles(log(unlist(x$mc_df[20, ])/100), percent_vals, "loss")
  }
))
colnames(mc_loss_percentiles_norm_df) <- fund_names
rownames(mc_loss_percentiles_norm_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(mc_loss_percentiles_norm_df, digits = 3)
```


### Worst ranking for MC loss percentiles

Skewed $t$-distribution (sstd):  

```{r}
knitr::kable(rank_summary(mc_loss_percentiles_df, sorting = rep("hi", length(percent_vals))), digits = 3)
```


Standardized $t$-distribution (std):  

```{r}
knitr::kable(rank_summary(mc_loss_percentiles_std_df, sorting = rep("hi", length(percent_vals))), digits = 3)
```


Normal distribution:  

```{r}
knitr::kable(rank_summary(mc_loss_percentiles_norm_df, sorting = rep("hi", length(percent_vals))), digits = 3)
```


## MC gains percentiles

```{r}
percent_vals = c(0, 5, 10, 25, 50, 100, 200, 300, 400, 500, 1000)
```


Skewed $t$-distribution (sstd):  

```{r}
mc_gain_percentiles_df <- as.data.frame(lapply(
  mc_output,
  function(x) {
    risk_percentiles(log(unlist(x$mc_df[20, ])/100), percent_vals, "gain")
  }
))
colnames(mc_gain_percentiles_df) <- fund_names
rownames(mc_gain_percentiles_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(mc_gain_percentiles_df, digits = 3)
```

1e6 sstd simulation paths of `mhr`: 

```{r}
# percent_vals = c(0, 5, 10, 25, 50, 100, 200, 300, 400, 500, 1000)
# mc_mhr_b_many_mc_loss_percentiles <-
#   data.frame(
#     percentiles = percent_vals,
#     prob=risk_percentiles(log(unlist(mc_mhr_b_many$mc_df[20, ])/100), percent_vals, "gain")
#   )
# t(mc_mhr_b_many_mc_loss_percentiles)
```

```{r}
percent_vals = c(0, 5, 10, 25, 50, 100, 200, 300, 400, 500, 1000)
mc_mhr_b_many_mc_gains_percentiles <- 
  data.frame(
    prob = c(99.8819, 99.8536, 99.824, 99.6861, 99.3009, 97.5134, 86.9115, 65.992, 41.486, 21.6928, 8.65e-02)
  )

rownames(mc_mhr_b_many_mc_gains_percentiles) <- as.character(percent_vals)
```

```{r}
knitr::kable(t(mc_mhr_b_many_mc_gains_percentiles), digits = 3)
```


Standardized $t$-distribution (std):  

```{r}
mc_gain_percentiles_std_df <- as.data.frame(lapply(
  mc_output_std,
  function(x) {
    risk_percentiles(log(unlist(x$mc_df[20, ])/100), percent_vals, "gain")
  }
))
colnames(mc_gain_percentiles_std_df) <- fund_names
rownames(mc_gain_percentiles_std_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(mc_gain_percentiles_std_df, digits = 3)
```


Normal distribution:  

```{r}
mc_gain_percentiles_norm_df <- as.data.frame(lapply(
  mc_output_norm,
  function(x) {
    risk_percentiles(log(unlist(x$mc_df[20, ])/100), percent_vals, "gain")
  }
))
colnames(mc_gain_percentiles_norm_df) <- fund_names
rownames(mc_gain_percentiles_norm_df) <- as.character(percent_vals)
```

```{r}
knitr::kable(mc_gain_percentiles_norm_df, digits = 3)
```



### Best ranking for MC gains percentiles

Skewed $t$-distribution (sstd):  

```{r}
knitr::kable(rank_summary(mc_gain_percentiles_df[1:6, ], sorting = rep("hi", length(percent_vals))), digits = 3)
```

```{r}
knitr::kable(rank_summary(mc_gain_percentiles_df[7:11, ], sorting = rep("hi", length(percent_vals))), digits = 3)
```


Standardized $t$-distribution (std):  

```{r}
knitr::kable(rank_summary(mc_gain_percentiles_std_df[1:6, ], sorting = rep("hi", length(percent_vals))), digits = 3)
```

```{r}
knitr::kable(rank_summary(mc_gain_percentiles_std_df[7:11, ], sorting = rep("hi", length(percent_vals))), digits = 3)
```


Normal distribution:  

```{r}
knitr::kable(rank_summary(mc_gain_percentiles_norm_df[1:6, ], sorting = rep("hi", length(percent_vals))), digits = 3)
```

```{r}
knitr::kable(rank_summary(mc_gain_percentiles_norm_df[7:11, ], sorting = rep("hi", length(percent_vals))), digits = 3)
```






## Summary statistics  

### Fit summary

Summary for fit of log returns to an F-S skew standardized Student-t distribution.  
`m`  is the location parameter.  
`s` is the scale parameter.  
`nu` is the estimated degrees of freedom, or shape parameter.  
`xi` is the estimated skewness parameter.  


Skewed $t$-distribution (sstd):  

```{r}
knitr::kable(fit_summary, digits = 3)
```


Standardized $t$-distribution (std):  

```{r}
knitr::kable(fit_summary_std, digits = 3)
```


Normal distribution:  

```{r}
knitr::kable(fit_summary_norm, digits = 3)
```


#### AIC and BIC  


AIC

```{r}
aic_df <- data.frame(matrix(numeric(3 * length(fund_names)), ncol = length(fund_names)))
for(i in seq_along(fits)) {
  aic_df[1, i] <- fits[[i]]$aic
}
for(i in seq_along(fits_std)) {
  aic_df[2, i] <- fits_std[[i]]$aic
}
for(i in seq_along(fits_norm)) {
  aic_df[3, i] <- fits_norm[[i]]$aic
}
colnames(aic_df) <- fund_names
rownames(aic_df) <- c("sstd", "std", "normal")
```


```{r}
knitr::kable(aic_df, digits = 3)
```


BIC  

```{r}
bic_df <- data.frame(matrix(numeric(3 * length(fund_names)), ncol = length(fund_names)))
for(i in seq_along(fits)) {
  bic_df[1, i] <- fits[[i]]$bic
}
for(i in seq_along(fits_std)) {
  bic_df[2, i] <- fits_std[[i]]$bic
}
for(i in seq_along(fits_norm)) {
  bic_df[3, i] <- fits_norm[[i]]$bic
}
colnames(bic_df) <- fund_names
rownames(bic_df) <- c("sstd", "std", "normal")
```

```{r}
knitr::kable(bic_df, digits = 3)
```


#### Fit statistics ranking  


Skewed $t$-distribution (sstd):  

```{r}
knitr::kable(rank_summary(fit_summary[c(1, 2, 5), ], sorting = c("hi", "lo", "hi")), digits = 3)
```


Standardized $t$-distribution (std):  

```{r}
knitr::kable(rank_summary(fit_summary_std[c(1, 2, 4), ], sorting = c("hi", "lo", "hi")), digits = 3)
```

Normal distribution:  

```{r}
knitr::kable(rank_summary(fit_summary_norm[c(1, 2, 3), ], sorting = c("hi", "lo", "hi")), digits = 3)
```



### Monte Carlo simulations summary

Monte Carlo simulations of portfolio index values (currency values).  
Statistics are given for the final state of all paths.  
Probability of down-and-out is calculated as the share of paths that reach 0 at
some point. All subsequent values for a path are set to 0, if the path reaches
at any point.  
0 is defined as any value below a threshold.    
`dai_pct` (for down-and-in) is the probability of losing money. This is calculated as the 
share of paths finishing below index 100.  

```{r}
cat("Number of paths:", mc_num_paths, "\n")
```


Skewed $t$-distribution (sstd):  

```{r}
mc_summary <- as.data.frame(lapply(
  mc_output,
  function(x) {
    c(x$mc_m, x$mc_s, x$mc_min, x$mc_max, x$dao_probability_percent, x$percent_losing_paths)
  }
))
colnames(mc_summary) <- fund_names
rownames(mc_summary) <- c("mc_m", "mc_s", "mc_min", "mc_max", "dao_pct", "dai_pct")
```

```{r}
knitr::kable(mc_summary, digits = 2)
```


Standardized $t$-distribution (std):  

```{r}
mc_summary_std <- as.data.frame(lapply(
  mc_output_std,
  function(x) {
    c(x$mc_m, x$mc_s, x$mc_min, x$mc_max, x$dao_probability_percent, x$percent_losing_paths)
  }
))
colnames(mc_summary_std) <- fund_names
rownames(mc_summary_std) <- c("mc_m", "mc_s", "mc_min", "mc_max", "dao_pct", "dai_pct")
```

```{r}
knitr::kable(mc_summary_std, digits = 2)
```


Normal distribution:  

```{r}
mc_summary_norm <- as.data.frame(lapply(
  mc_output_norm,
  function(x) {
    c(x$mc_m, x$mc_s, x$mc_min, x$mc_max, x$dao_probability_percent, x$percent_losing_paths)
  }
))
colnames(mc_summary_norm) <- fund_names
rownames(mc_summary_norm) <- c("mc_m", "mc_s", "mc_min", "mc_max", "dao_pct", "dai_pct")
```

```{r}
knitr::kable(mc_summary_norm, digits = 2)
```


#### Ranking  


Skewed $t$-distribution (sstd):  

```{r}
knitr::kable(rank_summary(mc_summary, sorting = c("hi", "lo", "hi", "hi", "lo", "lo")), digits = 2)
```


Standardized $t$-distribution (std):  

```{r}
knitr::kable(rank_summary(mc_summary_std, sorting = c("hi", "lo", "hi", "hi", "lo", "lo")), digits = 2)
```


Normal distribution:  

```{r}
knitr::kable(rank_summary(mc_summary_norm, sorting = c("hi", "lo", "hi", "hi", "lo", "lo")), digits = 2)
```



# Compare Gaussian and skewed t-distribution fits

## Gaussian fits

```{r eval=FALSE}
fits_norm <- as.data.frame(lapply(
  data_df,
  function(x) {
    fit_g <- fit_gauss(x)
    c(fit_g$par[1], fit_g$par[2])
  }
))
rownames(fits_norm) <- c("m", "s")
```

```{r eval=FALSE}
knitr::kable(fits_norm, digits = 3)
```

```{r fig.width=9, fig.height=12, eval=FALSE}
plot_norm_cdf <- function(x, m, s, minx, maxx, i) {
  plot(seq(from = minx, to = maxx, length.out = 100), pnorm(seq(from = minx, to = maxx, length.out = 100), m, s), pch = 16, cex = 0.3, type = "l", main = names(data_df)[i], xlab = "p", ylab = "log-return")
  abline(v = c(min(x), max(x)), col = c("red", "green"))
  abline(h = c(pnorm(min(x), m, s), pnorm(max(x), m,s)), col = c("red", "green"))
}

par(mfrow = c(4, 2))
for(i in 1:ncol(data_df)) {
  m <- fits_norm[, i][1]
  s <- fits_norm[, i][2]
  plot_norm_cdf(data_df[, i], m, s, -0.3, 0.3, i)
}
par(mfrow = c(1, 1))
```

### Gaussian QQ plots

```{r fig.width=9, fig.height=12, eval=FALSE}
plot_norm_qq <- function(x, m, s, i) {
  qqnorm((x - m) / s, main = names(data_df)[i])
  qqline((x - m) / s)
  abline(0, 1, col = "red")
  legend("bottomright", legend = c("fit", "y=x"), col = c("black", "red"), lty = 1)
}

par(mfrow = c(4, 2))
for(i in 1:ncol(data_df)) {
  m <- fits_norm[, i][1]
  s <- fits_norm[, i][2]
  plot_norm_qq(data_df[, i], m, s, i)
}
par(mfrow = c(1, 1))
```

### Gaussian vs skewed t

```{r}
# norm_probs <- as.data.frame(lapply(data_df, function(x) {
#   c(
#     pnorm(min(x), mean(x), sd(x)) * 100, 
#     (1 - pnorm(max(x), mean(x), sd(x))) * 100
#   )
# }))[, c(1, 4,2, 5, 3, 6)]
# rownames(norm_probs) <- c("P(X_min)", "P(X_max)")

make_extreme_probs <- function(data_df) {
  extreme_probs <- data.frame(matrix(4 * ncol(data_df), 4, ncol(data_df)))
  for(i in 1:ncol(data_df)) {
    x <- data_df[, i]
    extreme_probs[, i] <- c(
      pnorm(min(x), fits_norm[[i]]$dist_params[1], fits_norm[[i]]$dist_params[1]) * 100, 
      (1 - pnorm(max(x), fits_norm[[i]]$dist_params[1], fits_norm[[i]]$dist_params[2])) * 100,
      psstd(min(x), fit_summary["m", i], fit_summary["s", i], fit_summary["nu", i], fit_summary["xi", i]) * 100, 
      (1 - psstd(max(x), fit_summary["m", i], fit_summary["s", i], fit_summary["nu", i], fit_summary["xi", i])) * 100
    )
  }
  extreme_probs
}
extreme_probs <- make_extreme_probs(data_df)
colnames(extreme_probs) <- colnames(data_df)
rownames(extreme_probs) <- c("P_norm(X_min)", "P_norm(X_max)", "P_t(X_min)", "P_t(X_max)")


avg_yrs_btw_events <- 100/extreme_probs
rownames(avg_yrs_btw_events) <- c("norm: avg yrs btw min", "norm: avg yrs btw max", "t: avg yrs btw min", "t: avg yrs btw max")
```

Probability in percent that the smallest and largest (respectively) observed return for each fund was generated by a normal distribution:
```{r}
knitr::kable(extreme_probs, digits = 3)
```

Average number of years between min or max events (respectively):
```{r}
knitr::kable(avg_yrs_btw_events, digits = 3)
```


#### Lilliefors test  


```{r}
library(nortest)
```

```{r}
lillie_tests <- as.data.frame(lapply(
  data_df,
  function(x) {
    lillie.test(x)$p.value
  }
))
rownames(lillie_tests) <- "p value"
```

p-values for Lilliefors test.  
Testing $H_0$, that log-returns are Gaussian.

```{r}
knitr::kable(lillie_tests, digits = 3)
```



#### Wittgenstein's Ruler  


For different given probabilities that returns are Gaussian, what is the probability that the distribution is Gaussian rather than skewed t-distributed, given the smallest/largest observed log-returns?

Conditional probabilities for smallest observed log-returns:

```{r fig.width=9}
# Defining the different probabilities for P[gaussian]
p_gaussian_values <- 1 - 10^(-(seq(0, 6, length.out = 100)))
par(mfrow = c(2, 4))
for(i in seq_along(data_df)) {
  probs <- bayes_survival(
    p_gaussian_values, 
    min(data_df[[i]]),
    fits_norm[[i]]$dist_params,
    fits[[i]]$dist_params,
    mode = "min"
  )
  plot(p_gaussian_values, probs[[2]], pch = 16, cex = 0.3, 
       xlab = "P[Gauss]", ylab = "P[Gauss | event]",
       main = fund_names[i]
  )
  abline(0, 1, col = "red")
}
par(mfrow = c(1, 1))
```


Use $1 - \text{p-value}$ from Lilliefors test as prior probability that the distribution is Gaussian.  
$x_{\text{obs}} = \min(x)$ and $P[\text{Event}\ |\ \text{Gaussian}] = P_{\text{Gauss}}[X \leq x_{\text{min}}]$:

```{r}
wittgenstein_min <- as.data.frame(lapply(
  seq_along(data_df),
  function(i) {
    lillie_p <- unlist(lillie_tests[i])
    probs <- bayes_survival(
      1 - lillie_p, 
      min(data_df[[i]]),
      fits_norm[[i]]$dist_params,
      fits[[i]]$dist_params,
      mode = "min"
    )
    c(
      unlist(lillie_tests[i]),
      1 - lillie_p,
      unlist(probs[[2]])
    )
  }
))
colnames(wittgenstein_min) <- fund_names
rownames(wittgenstein_min) <- c("Lillie p-val", "Prior prob", "P[Gauss | Event]")
```

```{r}
knitr::kable(wittgenstein_min, digits = 3)
```



Use $1 - \text{p-value}$ from Lilliefors test as prior probability that the distribution is Gaussian.  
$x_{\text{obs}} = \max(x)$ and $P[\text{Event}\ |\ \text{Gaussian}] = P_{\text{Gauss}}[X \geq x_{\text{max}}]$:

```{r fig.width=9}
# Defining the different probabilities for P[gaussian]
p_gaussian_values <- 1 - 10^(-(seq(0, 6, length.out = 100)))
par(mfrow = c(2, 4))
for(i in seq_along(data_df)) {
  probs <- bayes_survival(
    p_gaussian_values, 
    max(data_df[[i]]),
    fits_norm[[i]]$dist_params,
    fits[[i]]$dist_params,
    mode = "max"
  )
  plot(p_gaussian_values, probs[[2]], pch = 16, cex = 0.3, 
       xlab = "P[Gauss]", ylab = "P[Gauss | event]",
       main = fund_names[i]
  )
  abline(0, 1, col = "red")
}
par(mfrow = c(1, 1))
```

```{r}
wittgenstein_max <- as.data.frame(lapply(
  seq_along(data_df),
  function(i) {
    lillie_p <- unlist(lillie_tests[i])
    probs <- bayes_survival(
      1 - lillie_p, 
      max(data_df[[i]]),
      fits_norm[[i]]$dist_params,
      fits[[i]]$dist_params,
      mode = "max"
    )
    c(
      unlist(lillie_tests[i]),
      1 - lillie_p,
      unlist(probs[[2]])
    )
  }
))
colnames(wittgenstein_max) <- fund_names
rownames(wittgenstein_max) <- c("Lillie p-val", "Prior prob", "P[Gauss | Event]")
```

```{r}
knitr::kable(wittgenstein_max, digits = 3)
```
