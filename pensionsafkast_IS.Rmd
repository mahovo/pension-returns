---
title: "psnsionsafkast_IS"
output: html_document
date: "2024-04-14"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r}
init_capital <- 100
num_prices <- 20
num_paths <- 1e2

num_steps <- num_prices - 1
```


```{r}
## Generate matrix of simulated X data
## Columns correspond to sample paths.
## num_steps is the length n of sample path.
## num_paths is the number of sample paths.
## rfunc is the random generating function, eg. runif, rnorm, etc.
## h(x) is simply log-returns, i.e. h(x) = x
x_gen_func_sstd <- function(fit, num_steps, num_paths) {
  m <- matrix(
    rsstd(num_steps * num_paths, fit$m, fit$s, fit$nu, fit$xi), 
    num_steps,
    num_paths, 
    byrow = FALSE
  )
  apply(m, 2, cumsum)
}

# x_gen_func_sstd <- function(fit, num_steps = num_steps , init_capital = 100 ) {
#   init_capital * exp(cumsum(rsstd(num_prices, fit$m, fit$s, fit$nu, fit$xi))) ## Pf index values
# }

x_gen_func <- function(num_steps, num_paths, rfunc = rsstd, ...) {
  cumsum(matrix(rfunc(n = num_steps * num_paths, ...), num_steps, num_paths, byrow = FALSE))
}

# x_gen_func <- function(num_steps = num_steps, init_capital = 100, rfunc = rsstd, ...) {
#   init_capital * exp(cumsum(rfunc(...)))
# }

xg_mat_gen <- function(num_steps, num_paths, qfunc, ...) {
  num_p_vals <- num_steps * num_paths
  p_mat <- matrix(
    runif(num_steps * num_paths, 0.0, 1.0),
    num_steps, num_paths, byrow = FALSE
  )

  matrix(qfunc(p = p_mat, ...), dim(p_mat))
}
```





```{r}
x_mat <- x_gen_func_sstd(
  fit = fit_mhr, 
  num_steps = num_steps, 
  num_paths = num_paths
)

log_returns <- apply(x_mat, 2, diff)
```


Distribution of simulated log-returns
```{r}
hist(log_returns, breaks = 40)
```

```{r}
log_ret_fit_normal <- MASS::fitdistr(log_returns, "normal")
log_ret_fit_normal
```

```{r}
log_ret_seq <- seq(min(log_returns), max(log_returns), length.out = 100)
log_ret_dens_data_norm <- dnorm(log_ret_seq, mean = log_ret_fit_normal$estimate[[1]], sd = log_ret_fit_normal$estimate[[2]])

hist(log_returns, breaks = 50, freq = FALSE, xlab = "log-returns", main = "Histogram of X and density of g")
lines(x = log_ret_seq, y = log_ret_dens_data_norm, col="red")
rug(log_returns)
```



```{r}
xg_mat <- xg_mat_gen(num_steps, num_paths, qfunc = qnorm, mean = log_ret_fit_normal$estimate[[1]], sd = log_ret_fit_normal$estimate[[2]])
```


```{r}
hist(xg_mat, breaks = 50, freq = FALSE, xlab = "log-returns", main = "Histogram of X_g")
```



```{r}
  ## For each theta value:
  ## - Generate num_paths paths of num_steps steps
  ## - Calcuate a vector gn-density density values for that theta value
  sd_vect <- numeric(num_test_runs)
  g_dens_mat <- matrix(numeric(num_test_runs * num_paths), num_paths, num_test_runs)
  w_star_mat <- matrix(numeric(num_test_runs * num_paths), num_paths, num_test_runs)
  for (i in 1:num_test_runs) {
    xg_mat <- xg_mat_gen(num_steps, num_paths, qfunc = qnorm, mean = 0, sd = 1)
    g_dens <- apply(xg_mat, 2, function(x) {gn_1(x, theta = theta_vals[i], a = -1.9, b = 2)})
    f_dens <- replicate(num_paths, (1/3.9)^num_steps)
    #f_dens <- replicate(num_paths, (1/3.9))
    g_dens_mat[, i] <- g_dens
    w_star_mat[, i] <-  f_dens / g_dens
    sd_vect_tmp <- sd(h_vect_gen_3(xg_mat, default) * w_star_mat[, i])
    sd_vect[i] <- sd_vect_tmp
  }
```








# Notes

Some thoughts...  
Portfolio index value diffs are path dependent. For instance a diff of 100 is very unlikely, if the previous index value is 5. But if the previous value is 1000, a diff of 100 is quite likely.

So instead of making an MC simulation of diffs, we should make a simulation of log-returns. From that we can then calculate and plot paths of index values.



If the columns in `x_mat` are vectors of portfolio index value differences:

```{r}
diffs <- lapply(mc_mhr_a$mc_df, diff)
```

```{r}
hist(unlist(diffs), breaks = 40)
```

Even though the distribution is visibly skewed, we use a normal distribution as $g(x)$. This is because it is very easy to fit a symmetric normal distribution with `fitdistr()`. Also the thin tails should offer the benefit of not down weighting the tails as much.


```{r}
diffs_fit_normal <- MASS::fitdistr(unlist(diffs), "normal")
diffs_fit_normal
```

```{r}
diffs_seq <- min(unlist(diffs)):max(unlist(diffs))
diffs_dens_data_norm <- dnorm(diffs_seq, mean = diffs_fit_normal$estimate[[1]], sd = diffs_fit_normal$estimate[[2]])

hist(unlist(diffs), breaks = 50, freq = FALSE, xlab = "diffs", main = "TÃ¦thed og histogram af diffs")
lines(x = diffs_seq, y = diffs_dens_data_norm, col="red")
rug(unlist(diffs))
```

Possible issue:  
The smallest value we will be deviding by is 1.212415e-29:
```{r}
min(diffs_dens_data_norm)
```

But we should try to minimize the sd of $h\cdot f/g^{*} \equiv h \cdot w^{*}$ wrt. the sd of the proposal distribution $g$

What happens if we use the distribution of $h \cdot f$ as $g$?  

$$\int \dfrac{h(x) f(x)}{h(x) f(x)}dx = \int 1 dx = x$$

